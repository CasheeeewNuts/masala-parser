import stream from '../../lib/stream/index';
import {F, C, N} from '../../lib/parsec/index';
import Option from '../../lib/data/option';
import unit from '../../lib/data/unit.js';
import response from "../../lib/parsec/response";

export default {
    setUp: function (done) {
        done();
    },
/*
    'expect (chain) to be accepted': function (test) {
        test.expect(1);
        // tests here
        var p1 = N.numberLiteral().thenLeft(C.char(' ').opt()),
            p2 = F.any().then(F.any()).thenLeft(F.eos()).map(function (r) {
                return r[0] + r[1];
            });

        test.equal(
            p1.chain(p2).parse(stream.ofString('12 34'), 0).isAccepted(),
            true,
            'should be accepted.'
        );
        test.done();
    },

    'expect (chain) to return 46': function (test) {
        test.expect(1);
        // tests here
        var p1 = N.numberLiteral().thenLeft(C.char(' ').opt()),
            p2 = F.any().then(F.any()).thenLeft(F.eos()).map(function (r) {
                return r[0] + r[1];
            });

        test.equal(
            p1.chain(p2).parse(stream.ofString('12 34'), 0).value,
            46,
            'should be 46.'
        );
        test.done();
    },
*/
    'expect chain to understand tokens': function (test) {

        // Genlex: read the chars
        // generator: [char] -> Genlex
        // list Parser ->

        // tokenBetweenSpaces(f)
        // f: GenLexFactory 'a -> -> Parser 'a char

        // token.parser : transforme en parser de token
        // Utilise literal; AppelÃ© au high level !!!


        // low level: would be generated by GenlexFactory

        // Parser (Token number) char
        let numberToken = N.numberLiteral()
            .debug('low number')
            .map(value => ({name:'number', value, precedence:500}));

        // Parser (Token char) char
        let plusToken = C.char('+')
            .debug('low +')
            .map(value => ({name:'plus', value:'+', precedence:1000}));


        // Now taken from the Genlex file

        let spacesToken = C.char(' ').optrep().map( ()=>unit);

        // ordering
        let lowLevelParser = plusToken.or(numberToken);

        let tokenBetweenSpaces = spacesToken.drop()
            .then(lowLevelParser)
            .then(spacesToken.drop());

        let tokens= tokenBetweenSpaces.rep(); // optrep ?

        // High level




        // Token -> Option 'a
        let plusAccept = token=> {
            console.log('plusAccept token :', token);
            return token.name === 'plus' ?
                Option.some({name:'plus', value:'+'}):
                Option.none();
        };

        // Token -> Option 'a
        let numberAccept = token => { // What is this token ?
            console.log('numberAccept token', token);
            token.name === 'number' ?
                Option.some({name:'number', value:token.value}):
                Option.none();
        };

        // Where I'm not sur at all...
        let tkNumber = literal(numberAccept);
        let tkPlus = literal(plusAccept);

        const highLevelParser = tkNumber.debug('high Number left')
            .then(tkPlus.debug('high +').drop())
            .then(tkNumber).debug('high Number right')
            .map( ([x,y]) => {
                console.log('result', x, y);
                return x + y;
        });



        let parser= tokens.chain(highLevelParser.thenLeft(F.eos().drop()));
        let parsing = parser.parse(stream.ofString('3 +8'));

        console.log(parsing.value, parsing);


    }
};


// (Token -> Option 'a) -> Parser 'a Token
function literal(tokenise) {
    //console.log('tokenize ', tokenise);
    return F.parse((input, index) =>
        input
            .get(index)
            .map(value =>
                tokenise(value)
                    .map(token =>
                        response.accept(token, input, index + 1, true)
                    )
                    .orLazyElse(() =>
                        response.reject(input.location(index), false)
                    )
            )
            .lazyRecoverWith(() =>
                response.reject(input.location(index), false)
            )
    );
}